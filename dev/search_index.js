var documenterSearchIndex = {"docs":
[{"location":"#Memento.jl-1","page":"Home","title":"Memento.jl","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"(Image: Build Status) (Image: Build status) (Image: codecov)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Memento is flexible hierarchical logging library for julia.","category":"page"},{"location":"#Installation-1","page":"Home","title":"Installation","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"julia> Pkg.add(\"Memento\")","category":"page"},{"location":"#Quick-Start-1","page":"Home","title":"Quick Start","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Start by using Memento","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> using Memento","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Now setup basic logging on the root logger with Memento.config!.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> logger = Memento.config!(\"debug\"; fmt=\"[{level} | {name}]: {msg}\")\nLogger(root)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Now start logging with the root logger.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> debug(logger, \"Something to help you track down a bug.\")\n[debug | root]: Something to help you track down a bug.\n\njulia> info(logger, \"Something you might want to know.\")\n[info | root]: Something you might want to know.\n\njulia> notice(logger, \"This is probably pretty important.\")\n[notice | root]: This is probably pretty important.\n\njulia> warn(logger, \"This might cause an error.\")\n[warn | root]: This might cause an error.\n\njulia> warn(logger, ErrorException(\"A caught exception that we want to log as a warning.\"))\n[warn | root]: A caught exception that we want to log as a warning.\n\njulia> error(logger, \"Something that should throw an error.\")\n[error | root]: Something that should throw an error.\nERROR: Something that should throw an error.\n in error(::Memento.Logger, ::String) at /Users/rory/.julia/v0.5/Memento/src/loggers.jl:250","category":"page"},{"location":"#","page":"Home","title":"Home","text":"Now maybe you want to have a different logger for each module/submodule. This allows you to have custom logging behaviour and handlers for different modules and provides easier to parse logging output.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"julia> child_logger = getlogger(\"Foo.bar\")\nLogger(Foo.bar)\n\njulia> setlevel!(child_logger, \"warn\")\n\"warn\"\n\njulia> push!(child_logger, DefaultHandler(tempname(), DefaultFormatter(\"[{date} | {level} | {name}]: {msg}\")))\n\nMemento.DefaultHandler{Memento.DefaultFormatter,IOStream}(Memento.DefaultFormatter(\"[{date} | {level} | {name}]: {msg}\"),IOStream(<file /var/folders/_6/25myjdtx2fxgjvznn19rp22m0000gn/T/julia8lonyA>),Dict{Symbol,Any}(Pair{Symbol,Any}(:is_colorized,false)))\n\njulia> debug(child_logger, \"Something that should only be printed to stdout on the root_logger.\")\n[debug | Foo.bar]: Something that should only be printed to stdout on the root_logger.\n\njulia> warn(child_logger, \"Warning to stdout and the log file.\")\n[warn | Foo.bar]: Warning to stdout and the log file.","category":"page"},{"location":"#","page":"Home","title":"Home","text":"NOTE: We used getlogger(\"Foo.bar\"), but you can also do getlogger(@__MODULE__) which allows us to avoid hard coding in logger names.","category":"page"},{"location":"#Piggybacking-onto-another-package's-logger-1","page":"Home","title":"Piggybacking onto another package's logger","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"To add logging events using another package's logger in your own module/package you can do:","category":"page"},{"location":"#","page":"Home","title":"Home","text":"module MyModule\n\nusing OtherPackage\nusing Memento\n\n# Set package logger to be available for configuration at runtime\nfunction __init__()\n    global LOGGER = getlogger(\"OtherPackage\")\nend\n\nfunction my_func()\n    warn(LOGGER, \"MyModule warning\")\nend\n\nend  # MyModule","category":"page"},{"location":"man/intro/#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"man/intro/#Logging-levels-1","page":"Introduction","title":"Logging levels","text":"","category":"section"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"You can globally set the minimum logging level with Memento.config!.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"julia> Memento.config!(\"debug\")","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Will log all messages for all loggers at or above \"debug\".","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"julia> Memento.config!(\"warn\")","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Will only log message at or above the \"warn\" level.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"We can also set the logging level for specific loggers or collections of loggers if we explicitly set the level on an existing logger.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"julia> setlevel!(getlogger(\"Main\"), \"info\")","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Will only set the logging level to \"info\" for the \"Main\" logger and any future children of the \"Main\" logger.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"By default Memento has 10 logging levels.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Level Number Description\nnot_set 0 Will not log anything, but may still propagate messages to its parents.\ntrace 5 Log messages only intended for tracing program execution.\ndebug 10 Log verbose message used for debugging.\ninfo 20 Log general information about a program.\nnotice 30 Log important events that are still part of normal execution.\nwarn 40 Log warning that may cause the program to fail.\nerror 50 Log errors and throw or rethrow an error.\ncritical 60 Entire application has crashed.\nalert 70 The entire application crashed and is not recoverable. Probably need to wake up the sysadmin.\nemergency 80 System is unusable. Applications shouldn't need to call this so it may be removed in the future.","category":"page"},{"location":"man/intro/#Formatting-logs-1","page":"Introduction","title":"Formatting logs","text":"","category":"section"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Unless explicitly changed Memento will use a DefaultFormatter for handlers. This Formatter takes a format string for mapping log record fields into each log message. Desired fields are wrapped in curly brackets (ie: \"{msg}\")","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"The default format string is \"[{level} | {name}]: {msg}\", which produces messages that look like","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"[info | root]: my info message.\n[warn | root]: my warning message.\n...","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"However, you could change this string to just \"{level}: {msg}\", which would produce messages that look like","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"info: my info message.\nwarn: my warning message.\n...","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"The simplest way to globally change the log format is with Memento.config!:","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"julia> Memento.config!(\"debug\"; fmt=\"[{level} | {name}]: {msg}\")","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"The following fields are available via the DefaultRecord.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Field Description\ndate The log event date rounded to seconds\nlevel The log event level as a string\nlevelnum The integer value for the log event level\nmsg The source log event message\nname The name of the source logger\npid The pid where the log event occured\nlookup The top StackFrame of the stacktrace for the log event\nstacktrace A StackTrace for the log event","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"For more details on the DefaultFormatter and DefaultRecord please see the API docs. More general information on Formatters and Records will be discussed later in this manual.","category":"page"},{"location":"man/intro/#Architecture-1","page":"Introduction","title":"Architecture","text":"","category":"section"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Memento is a hierarchical logging library, meaning that loggers may have child loggers with their own configurations (e.g., levels, handlers, record types). By default, logs sent to child loggers propagate up to the root logger, allowing for a simple default configuration at the root. Memento.jl is designed to separate the responsibilities of logging in libraries (e.g., modules, packages) vs applications. In general, libraries should focus on logging relevant messages to a library specific child logger, and avoid configuring the child logger directly.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"module MyModule\n\nusing Memento\n\nconst LOGGER = getlogger(@__MODULE__)\n\n__init__() = Memento.register(LOGGER)\nnoisy() = debug(LOGGER, \"LOUD NOISES!\")\nhello() = info(LOGGER, \"Hello World!\")\ndanger() = warn(LOGGER, \"Danger Zone!\")\n\nend","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"See the package usage docs for details.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"On the other hand, applications are responsible for setting logging levels and attaching custom handlers to specific child loggers as needed.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"using Memento\nusing MyModule\n\n# Configure global logging level and formatting\nMemento.config!(\"info\"; fmt=\"[{level} | {name}]: {msg}\")\npush!(getlogger(\"MyModule\"), DefaultHandler(\"noisy.log\"))\n\n# Will only log to noisy.log and not the console\nMyModule.noisy()\n\n# These will log to both noisy.log and the console\nMyModule.hello()\nMyModule.danger()","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"See some of our configuration recipes for more details.","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"There are five main components of Memento.jl that you can manipulate:","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"Loggers\nHandlers\nFormatters\nRecords\nIO","category":"page"},{"location":"man/intro/#","page":"Introduction","title":"Introduction","text":"The remainder of this manual will discuss how you can use these components to customize Memento to you particular application.","category":"page"},{"location":"man/loggers/#man_loggers-1","page":"Loggers","title":"Loggers","text":"","category":"section"},{"location":"man/loggers/#","page":"Loggers","title":"Loggers","text":"A Logger is the primary component you use to send formatted log messages to various IO outputs. This type holds information needed to manage the process of creating and storing logs. There is a default \"root\" logger stored in const _loggers inside the Memento module. Since Memento implements hierarchical logging you should define child loggers that can be configured independently and better describe the individual components within your code. To create a new logger for you code it is recommended to do getlogger(@__MODULE__).","category":"page"},{"location":"man/loggers/#","page":"Loggers","title":"Loggers","text":"julia> logger = getlogger(@__MODULE__)","category":"page"},{"location":"man/loggers/#","page":"Loggers","title":"Loggers","text":"Log messages are brought to different output streams by Handlers. From here you can add and remove handlers. To add a handler that writes to rotating log files, simply:","category":"page"},{"location":"man/loggers/#","page":"Loggers","title":"Loggers","text":"julia> push!(logger, DefaultHandler(\"mylogfile.log\"))","category":"page"},{"location":"man/loggers/#","page":"Loggers","title":"Loggers","text":"Now there is a handler named \"file-logging\", and it will write all of your logs to mylogfile.log. Your logs will still show up in the console, however, because by default there is a handler named \"console\" already hard at work.","category":"page"},{"location":"man/loggers/#","page":"Loggers","title":"Loggers","text":"The operations presented here will only apply to the current logger, leaving existing loggers (e.g., Logger(root)) unaffected. However, any child loggers of Logger(Main) (e.g., Logger(Main.Foo) will have both the \"console\" and \"file-logging\" handlers available to it.","category":"page"},{"location":"man/loggers/#","page":"Loggers","title":"Loggers","text":"We can also set the level and Record type for our logger.","category":"page"},{"location":"man/loggers/#","page":"Loggers","title":"Loggers","text":"julia> setlevel!(logger, \"warn\")","category":"page"},{"location":"man/loggers/#","page":"Loggers","title":"Loggers","text":"Now we won't log any messages with this logger unless they are at least warning messages.","category":"page"},{"location":"man/loggers/#","page":"Loggers","title":"Loggers","text":"julia> setrecord!(logger, MyRecord)","category":"page"},{"location":"man/loggers/#","page":"Loggers","title":"Loggers","text":"Now our logger will call create MyRecords instead of DefaultRecords","category":"page"},{"location":"man/handlers/#man_handlers-1","page":"Handlers","title":"Handlers","text":"","category":"section"},{"location":"man/handlers/#","page":"Handlers","title":"Handlers","text":"As we've already seen, Handlers can be used to write log messages to different IO types. More specifically, handlers are parameterized types that describe the relationship of how Formatter and IO types are used to take a Record (a kind of specified Dict) -> convert it to a String with the Formatter and write that to an IO type.","category":"page"},{"location":"man/handlers/#","page":"Handlers","title":"Handlers","text":"In the simplest case a Handler definition would like:","category":"page"},{"location":"man/handlers/#","page":"Handlers","title":"Handlers","text":"mutable struct MyHandler{F<:Formatter, O<:IO} <: Handler{F, O}\n    fmt::F\n    io::O\nend\n\nfunction emit(handler::MyHandler{F, O}, rec::Record) where {F<:Formatter, O<:IO}\n    str = Memento.format(handler.fmt, rec)\n    println(handler.io, str)\n    flush(handler.io)\nend","category":"page"},{"location":"man/handlers/#","page":"Handlers","title":"Handlers","text":"However, under some circumstances it may be necessary to customize this behaviour based on the Formatter, IO or Record types being used. For example, if you'd like to use the Syslog IO type from Syslogs.jl you'll need topass in an extra level argument to its println so we special case this like so:","category":"page"},{"location":"man/handlers/#","page":"Handlers","title":"Handlers","text":"using Syslogs\n\nfunction emit(handler::MyHandler{F, O}, rec::Record) where {F<:Formatter, O<:Syslog}\n    str = Memento.format(handler.fmt, rec)\n    println(handler.io, rec.level, str)\n    flush(handler.io)\nend","category":"page"},{"location":"man/formatters/#man_formatters-1","page":"Formatters","title":"Formatters","text":"","category":"section"},{"location":"man/formatters/#","page":"Formatters","title":"Formatters","text":"Formatters describe how to take a Record and convert it into properly formatted string. Currently, there are two types of Formatters.","category":"page"},{"location":"man/formatters/#","page":"Formatters","title":"Formatters","text":"DefaultFormatter: use a simple template string format to map keys in the Record to places in the resulting string. (ie: DefaultFormatter(\"[{date} | {level} | {name}]: {msg}\")\nDictFormatter: builds an appropriately formatted Dict from the Record so that it can be serialized to a string with various formats. (e.g., string, JSON.json).","category":"page"},{"location":"man/formatters/#","page":"Formatters","title":"Formatters","text":"You should only need to write a custom Formatter type if you're needing to produce very specific string formats regardless of the Record type being used. For example, we may want a CSVFormatter which always writes logs in a CSV Format.","category":"page"},{"location":"man/formatters/#","page":"Formatters","title":"Formatters","text":"If you just need to customize the behaviour of an existing Formatter to a specific Record type then you should simply overload the format method for that Formatter.","category":"page"},{"location":"man/formatters/#Example-1","page":"Formatters","title":"Example","text":"","category":"section"},{"location":"man/formatters/#","page":"Formatters","title":"Formatters","text":"function Memento.format(fmt::DefaultFormatter, rec::MyRecord)\n    ...\nend","category":"page"},{"location":"man/records/#man_records-1","page":"Records","title":"Records","text":"","category":"section"},{"location":"man/records/#","page":"Records","title":"Records","text":"Records store information about log events (e.g., message, timestamp, log level) that is used by Formatters to format log messages. A record behaves as a dictionary-like container with Symbol keys, and you can access the properties of a Record by using getproperty (i.e., record.msg).","category":"page"},{"location":"man/records/#","page":"Records","title":"Records","text":"By default, any subtypes of Record will treat its fields as keys. Non-standard subtypes of Record should implement getproperty(::MyRecord, ::Symbol) and key-value pair iteration.","category":"page"},{"location":"man/records/#AttributeRecords-1","page":"Records","title":"AttributeRecords","text":"","category":"section"},{"location":"man/records/#","page":"Records","title":"Records","text":"An AttributeRecord is an abstract subtype of Record that lazily evaluates its properties. Fields are stored as Attributes, which will evaluate a function and cache the result the first time it is read.","category":"page"},{"location":"man/records/#","page":"Records","title":"Records","text":"By default, any subtypes of AttributeRecord will expect its fields to be Attributes. Non-standard subtypes of AttributeRecord should implement Base.getproperty(::MyRecord, ::Symbol) and key-value pair iteration, where the values have been extracted from Attributes using get.","category":"page"},{"location":"man/records/#Custom-Record-Types-1","page":"Records","title":"Custom Record Types","text":"","category":"section"},{"location":"man/records/#","page":"Records","title":"Records","text":"While the DefaultRecord in Memento (a standard AttributeRecord) provides many of the keys and values needed for most logging applications, you may need to implement your own Record type. For example, if you're running a julia application on a cloud service provider like Amazon's EC2 you might want to include some general information about the resource your code is running on, which might result in a custom Record type that looks like:","category":"page"},{"location":"man/records/#","page":"Records","title":"Records","text":"# TODO: Fix this example.\nmutable struct EC2Record <: AttributeRecord\n    date::Attribute\n    level::Attribute\n    levelnum::Attribute\n    msg::Attribute\n    name::Attribute\n    pid::Attribute\n    lookup::Attribute\n    stacktrace::Attribute\n    instance_id::Attribute\n    public_ip::Attribute\n    iam_user::Attribute\n\n    function EC2Record(name::AbstractString, level::AbstractString, levelnum::Int, msg)\n        time = now()\n        trace = Attribute{StackTrace}(get_trace)\n\n        EC2Record(\n            Attribute{DateTime}(() -> round(time, Dates.Second)),\n            Attribute(level),\n            Attribute(levelnum),\n            Attribute{AbstractString}(msg),\n            Attribute(name),\n            Attribute(getpid()),\n            Attribute{StackFrame}(get_lookup(trace)),\n            trace,\n            Attribute(ENV[\"INSTANCE_ID\"]),\n            Attribute(ENV[\"PUBLIC_IP\"]),\n            Attribute(ENV[\"IAM_USER\"]),\n        )\n    end\nend","category":"page"},{"location":"man/records/#","page":"Records","title":"Records","text":"NOTE: The above example simply assumes that you have some relevant environment variables set on the machine, but you could also query Amazon for that information.","category":"page"},{"location":"man/io/#man_io-1","page":"IO","title":"IO","text":"","category":"section"},{"location":"man/io/#","page":"IO","title":"IO","text":"Memento writes all logs to any subtype of IO including IOBuffers, LibuvStreams, Pipes, Files, etc. Memento also comes with a logging-specific IO type, FileRoller, which does automatic log file rotation.","category":"page"},{"location":"man/io/#","page":"IO","title":"IO","text":"The Syslogs package provides the Syslog IO type to write to syslog using the logger command. Please note that syslog output is only available on systems that have logger utility installed (this should include both Linux and macOS, but typically excludes Windows). Note that BSD's logger (used on macOS) will append a second process ID, which is the PID of the logger tool itself.","category":"page"},{"location":"man/io/#","page":"IO","title":"IO","text":"To create your own IO types for use with Memento you need to subtype IO and implement the println and flush methods.","category":"page"},{"location":"man/conclusion/#Conclusion-1","page":"Conclusion","title":"Conclusion","text":"","category":"section"},{"location":"man/conclusion/#","page":"Conclusion","title":"Conclusion","text":"We've reviewed all the different components you can use to configure logging in you application, but how do they all fit together? Let's work through a sample use case that uses all of the components we've discussed.","category":"page"},{"location":"man/conclusion/#","page":"Conclusion","title":"Conclusion","text":"NOTE: The example provided is a bit contrived for simplicity.","category":"page"},{"location":"man/conclusion/#","page":"Conclusion","title":"Conclusion","text":"First, let's start with a julia Pkg called Wrapper that runs a function wrapped in some Memento logging.","category":"page"},{"location":"man/conclusion/#","page":"Conclusion","title":"Conclusion","text":"# Wrapper.jl\nmodule Wrapper\n\nusing Memento\n\nfunction run(f::Function, args...; kwargs...)\n    ret = nothing\n    logger = getlogger(current_module())\n    info(logger, \"Got logger $logger\")\n\n    notice(logger, \"Running function...\")\n\n    try\n        ret = f(args...; kwargs...)\n    catch exc\n        warn(logger, exc)\n    end\n\n    return ret\nend\n\nend","category":"page"},{"location":"man/conclusion/#","page":"Conclusion","title":"Conclusion","text":"Now we want to start writing our application code that uses this package, but our logging requirements are very specific and Memento doesn't support our particular use case yet.","category":"page"},{"location":"man/conclusion/#","page":"Conclusion","title":"Conclusion","text":"Requirements:","category":"page"},{"location":"man/conclusion/#","page":"Conclusion","title":"Conclusion","text":"This will be run on Amazon EC2 instances and we want our log message to contain information about the machine the code is being run on.\nWe want our logs to be written to an HTTP REST service (kinda like Loggly), where the endpoint is of the form https://<account_uri>/<app_name>/<level>?AccessKey=<access_key>.\nWe want our logs to be written in a CSV format... for some reason.","category":"page"},{"location":"man/conclusion/#","page":"Conclusion","title":"Conclusion","text":"Okay, so how do we address all of those requirements using Memento's API?","category":"page"},{"location":"man/conclusion/#","page":"Conclusion","title":"Conclusion","text":"Steps:","category":"page"},{"location":"man/conclusion/#","page":"Conclusion","title":"Conclusion","text":"Create a custom Record type called EC2Record that stores the Amazon EC2 information to address the first requirement.\nCreate a custom IO type called REST that writes log strings to the REST endpoint to partly address the second requirement.\nCreate a custom Formatter type called CSVFormatter that converts Records to (comma, tab, etc) delimited strings.","category":"page"},{"location":"man/conclusion/#","page":"Conclusion","title":"Conclusion","text":"NOTE: The code below is not intended to be a working example because it assumes a fake REST service.","category":"page"},{"location":"man/conclusion/#","page":"Conclusion","title":"Conclusion","text":"# myapp.jl\nusing Wrapper\nusing Memento\nusing Requests  # For send logs to our fake logging REST service\n\n# Start by setting up our basic console logging for the root logger.\nlogger = Memento.config!(\"info\"; fmt=\"[{level} | {name}]: {msg}\")\n\n# We create our custom EC2Record type\nmutable struct EC2Record <: Record\n    date::Attribute\n    level::Attribute\n    levelnum::Attribute\n    msg::Attribute\n    name::Attribute\n    pid::Attribute\n    lookup::Attribute\n    stacktrace::Attribute\n    instance_id::Attribute\n    public_ip::Attribute\n    iam_user::Attribute\n\n    function EC2Record(args::Dict)\n        time = now()\n        trace = Attribute{StackTrace}(get_trace)\n\n        EC2Record(\n            Attribute{DateTime}(() -> round(time, Dates.Second)),\n            Attribute(args[:level]),\n            Attribute(args[:levelnum]),\n            Attribute{AbstractString}(get_msg(args[:msg])),\n            Attribute(args[:name]),\n            Attribute(myid()),\n            Attribute{StackFrame}(get_lookup(trace)),\n            trace,\n            Attribute(ENV[\"INSTANCE_ID\"]),\n            Attribute(ENV[\"PUBLIC_IP\"]),\n            Attribute(ENV[\"IAM_USER\"]),\n        )\n    end\nend\n\n# A really simple CSVFormatter\nmutable struct CSVFormatter <: Formatter\n    delim::Char\n    vals::Vector{Symbol}\n\n    CSVFormatter(delim=',', vals=Vector{Symbol}()) = new(delim, vals)\nend\n\nfunction format(fmt::CSVFormatter, rec::Record)\n    fields = isempty(fmt.vals) ? keys(rec) : fmt.vals\n\n    # For a real world use case we might want to do some\n    # string formatting of fields like :stacktrace here.\n\n    val = map(k -> rec[k], fields)\n\n    return join(val, fmt.delim)\nend\n\n# Create our custom REST IO type\nmutable struct REST <: IO\n    account_uri::AbstractString\n    app_name::AbstractString\n    access_key::AbstractString\nend\n\n# Our print method builds the correct uri using the log level\n# and sends the put request.\nfunction println(io::REST, level::AbstractString, msg::AbstractString)\n    uri = \"https://$(io.account_uri)/$(io.app_name)/$level?AccessKey=$(io.access_key)\"\n    @async put(uri; data=msg)\nend\n\n# Not relevant, but good to have.\nflush(io::REST) = io\n\n# We still need to special case the `DefaultHandler` `log` method to call  `println(io::REST, level, msg)`\nfunction log(handler::DefaultHandler{F, O}, rec::Record) where {F<:Formatter, O<:REST}\n    msg = format(handler.fmt, rec)\n    println(handler.io, rec.level, msg)\n    flush(handler.io)\nend\n\n# Now we can tie this all together, but adding a new DefaultHandler\n# with the CSVFormatter and REST IO type.\npush!(\n    logger,\n    DefaultHandler(\n        REST(\n            \"memento.mylogrestservice.com\", \"myapp\",\n            \"qM033cSYWTuu8VpXFSZm9QMm9ZESOU2A\"\n        ),\n        CSVFormatter(\n            ',',\n            [:date, :name, :level, :msg, :iam_user, :public_ip, :instance_id]\n        )\n    )\n)\n\n# Don't forget to update the root logger `Record` type.\nsetrecord!(logger, EC2Record)\n\nWrapper.run(exp, 10)\n# Should log some things.\n\nWrapper.run(exp, \"foo\")\n# Should log a warning about a method error.","category":"page"},{"location":"faq/another-logging-lib/#yall-1","page":"Another logging library?","title":"Another logging library?","text":"","category":"section"},{"location":"faq/another-logging-lib/#","page":"Another logging library?","title":"Another logging library?","text":"...or why did you fork Lumberjack.jl?","category":"page"},{"location":"faq/another-logging-lib/#","page":"Another logging library?","title":"Another logging library?","text":"The short answer is that none of the existing logging libraries quite fit our requirements. The summary table provided below shows that all of the existing libraries are missing more than 1 requirement. Our initial goal was to add more tests, hierarchical logging and some API changes to Lumberjack as it seemed to have the best balance of features and test coverage. In the end, our changes diverged enough from Lumberjack that it made more sense to fork the project.","category":"page"},{"location":"faq/another-logging-lib/#","page":"Another logging library?","title":"Another logging library?","text":"Properties Logging.jl Lumberjack.jl MiniLogging.jl Memento.jl\nVersions 0.3.1 2.1.0 0.0.2 N/A\nCoverage 61% 76% 87% 100%\nUnix Yes Yes Yes Yes\nWindows Yes No No Yes\nJulia 0.4, 0.5 0.4, 0.5 0.5 0.5\nHierarchical Kinda No Yes Yes\nCustom Formatting No Kinda No Yes\nCustom IO Types Yes Yes Yes Yes\nSyslog Yes Yes No Yes\nColor Yes Yes No Yes","category":"page"},{"location":"faq/another-logging-lib/#","page":"Another logging library?","title":"Another logging library?","text":"You can see from the table that Memento covers all of our logging requirements and has significantly higher test coverage.","category":"page"},{"location":"faq/change-colors/#change_colors-1","page":"Changing colors?","title":"Changing colors?","text":"","category":"section"},{"location":"faq/change-colors/#","page":"Changing colors?","title":"Changing colors?","text":"Colors can be enabled/disabled and set using via the is_colorized and colors options to the DefaultHandler.","category":"page"},{"location":"faq/change-colors/#","page":"Changing colors?","title":"Changing colors?","text":"julia> push!(logger, DefaultHandler(\n    stdout, DefaultFormatter(),\n    Dict{Symbol, Any}(:is_colorized => true))\n)","category":"page"},{"location":"faq/change-colors/#","page":"Changing colors?","title":"Changing colors?","text":"will create a DefaultHandler with colorization.","category":"page"},{"location":"faq/change-colors/#","page":"Changing colors?","title":"Changing colors?","text":"By default the following colors are used:","category":"page"},{"location":"faq/change-colors/#","page":"Changing colors?","title":"Changing colors?","text":"Dict{AbstractString, Symbol}(\n    \"trace\" => :normal,\n    \"debug\" => :blue,\n    \"info\" => :green,\n    \"notice\" => :cyan,\n    \"warn\" => :magenta,\n    \"error\" => :red,\n    \"critical\" => :yellow,\n    \"alert\" => :white,\n    \"emergency\" => :black,\n)","category":"page"},{"location":"faq/change-colors/#","page":"Changing colors?","title":"Changing colors?","text":"However, you can specify custom colors/log levels like so:","category":"page"},{"location":"faq/change-colors/#","page":"Changing colors?","title":"Changing colors?","text":"push!(logger, DefaultHandler(\n    stdout, DefaultFormatter(),\n    Dict{Symbol, Any}(\n        :colors => Dict{AbstractString, Symbol}(\n            \"trace\" => :magenta,\n            \"debug\" => :black,\n            \"info\" => :blue,\n            \"warn\" => :yellow,\n            \"error\" => :red,\n            \"panic\" => :green,\n        )\n    )\n)","category":"page"},{"location":"faq/change-colors/#","page":"Changing colors?","title":"Changing colors?","text":"You can also globally disable colorization when running Memento.config!","category":"page"},{"location":"faq/change-colors/#","page":"Changing colors?","title":"Changing colors?","text":"julia> Memento.config!(\"info\"; fmt=\"[{date} | {level} | {name}]: {msg}\", colorized=false)","category":"page"},{"location":"faq/config-recipes/#config_recipes-1","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"","category":"section"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"So we've provided examples of many different ways that Memento.jl can be extended, but what are some common examples for configuring Memento out of the box, without extending any components.","category":"page"},{"location":"faq/config-recipes/#Logging-to-a-File-1","page":"Configuring Logging in Applications?","title":"Logging to a File","text":"","category":"section"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"I want all my log messages coming from MyPkg to be saved to a local file. Easy, just add a DefaultHandler with the desired filename to the specific child logger.","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"push!(getlogger(\"MyPkg\"), DefaultHandler(\"noisy.log\"))","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"If you want trace and debug level logging as well then just set the level on that logger.","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"setlevel!(getlogger(\"MyPkg\"), \"trace\")","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"This will send trace messages to all handlers attached to the MyPkg logger, but these want be emitted from the root logger where the default level is info.","category":"page"},{"location":"faq/config-recipes/#Silence-Loggers-1","page":"Configuring Logging in Applications?","title":"Silence Loggers","text":"","category":"section"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"Have some noisy dependencies that you'd like to silence? Maybe the package owner needs to make some info messages debug only? Until that's fixed you can always silence info logs from the package in you application.","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"setlevel!(getlogger(\"NoisyPkg\"), \"notice\")","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"All trace, debug and info messages from NoisyPkg and submodules will no longer propagate to the root logger and emit logs to the console.","category":"page"},{"location":"faq/config-recipes/#Selective-Debugging-1","page":"Configuring Logging in Applications?","title":"Selective Debugging","text":"","category":"section"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"Found a bug and need to enable selective debug logging around where the error occurs? There are two ways you can do this in Memento. The simplest option is to call setlevel! for all loggers along the desired path.","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"setlevel!.(Memento.getpath(getlogger(\"MyPkg\")), \"debug\")","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"In this example, Logger(root) and Logger(MyPkg) are now set to debug, and debugging messages will propagate along that path to the root default handler.","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"Pros:","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"Reuses the root default handler\nSingle line of code\nEnables debug logging for related loggers (e.g., parents)","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"Cons:","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"May produce too much noisy if you don't want debug message from parents.","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"Alternatively, if you want only debug level messages for a specific logger and you don't want any extra logs from the parents then you'll need to modify that logger's level and add a custom handler.","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"mypkg_logger = getlogger(\"MyPkg\")\nsetlevel!(mypkg_logger, \"debug\")\nhandler = DefaultHandler(\n    stdout,\n    DefaultFormatter(\"[{date} | {level} | {name}]: {msg}\")\n)\npush!(mypkg_logger, handler)","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"This will log all debug or higher messages to this new custom handler.","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"NOTE: This may result in duplicate logs as the custom handler will emit info, notice, warn, etc logs, but those will also propagate up to the root logger. To avoid this you may wish to add a custom filter to your custom handler to only log debug messages.","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"push!(handler, Memento.Filter(r -> getlevel(r) == \"debug\"))","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"Pros:","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"Fine grained control over debug message handling\nFlexible filtering options","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"Cons:","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"Verbose\nRequires greater understanding of the logger hierarchy and record propagation","category":"page"},{"location":"faq/config-recipes/#Integration-with-Base-Julia-Logging-1","page":"Configuring Logging in Applications?","title":"Integration with Base Julia Logging","text":"","category":"section"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"Want to use Memento's logger hierarchy, formatter, filters or handlers with the base logging macros (e.g., @info, @warn)? You just need to pass substitute=true to Memento.config! and Memento will start intercepting any logs generated by those macros.","category":"page"},{"location":"faq/config-recipes/#","page":"Configuring Logging in Applications?","title":"Configuring Logging in Applications?","text":"Memento.config!(\"info\"; fmt=\"[{date} | {level} | {name}]: {msg}\", substitute=true)\n@info(\"Hello World!\")","category":"page"},{"location":"faq/logging-to-syslog/#syslogs-1","page":"Logging to Syslog?","title":"Logging to Syslog?","text":"","category":"section"},{"location":"faq/logging-to-syslog/#","page":"Logging to Syslog?","title":"Logging to Syslog?","text":"In Memento v0.4, the builtin Syslog type was moved into its own package Syslogs.jl which allows folks to use either Syslogs.jl or Memento.jl independently from one another. Unfortunately, this does require the following bit of glue code in your projects.","category":"page"},{"location":"faq/logging-to-syslog/#","page":"Logging to Syslog?","title":"Logging to Syslog?","text":"# Load up `Syslogs.jl` where `Syslog` will be exported by default.\nusing Syslogs\n\n# Define a 2 line glue method as the `Syslog` type requires a level argument be passed into\n# the `println` method.\nfunction Memento.emit(handler::DefaultHandler{F, O}, rec::Record) where {F<:Formatter, O<:Syslog}\n    println(handler.io, rec.level, format(handler.fmt, rec))\n    flush(handler.io)\nend\n\n# NOTE: This glue code is only necessary because Julia (as of v0.7) doesn't provide a good\n# mechanism for handling optional dependencies.","category":"page"},{"location":"faq/logging-to-syslog/#","page":"Logging to Syslog?","title":"Logging to Syslog?","text":"Now we can start logging to syslog locally:","category":"page"},{"location":"faq/logging-to-syslog/#","page":"Logging to Syslog?","title":"Logging to Syslog?","text":"push!(\n    logger,\n    DefaultHandler(\n        Syslog(),\n        DefaultFormatter(\"{level}: {msg}\")\n    )\n)","category":"page"},{"location":"faq/logging-to-syslog/#","page":"Logging to Syslog?","title":"Logging to Syslog?","text":"We can also log to remote syslog servers via UDP or TCP:","category":"page"},{"location":"faq/logging-to-syslog/#","page":"Logging to Syslog?","title":"Logging to Syslog?","text":"push!(\n    logger,\n    DefaultHandler(\n        Syslog(ip\"123.34.56.78\"),\n        DefaultFormatter(\"{level}: {msg}\")\n    )\n)","category":"page"},{"location":"faq/json-formatting/#json-fmt-1","page":"Producing JSON logs?","title":"Producing JSON logs?","text":"","category":"section"},{"location":"faq/json-formatting/#","page":"Producing JSON logs?","title":"Producing JSON logs?","text":"In Memento v0.4, the JsonFormatter type was converted into a more general DictFormatter which allowed us to drop JSON.jl as a dependency. However, the original behaviour can still be easily achieved by passing in JSON.json to the DictFormatter constructor.","category":"page"},{"location":"faq/json-formatting/#","page":"Producing JSON logs?","title":"Producing JSON logs?","text":"using JSON\n\npush!(\n    logger,\n    DefaultHandler(\n        \"json-output.log\",\n        DictFormatter(JSON.json)\n    )\n)","category":"page"},{"location":"faq/pkg-usage/#pkg_usage-1","page":"Using Memento in Julia packages?","title":"Using Memento in Julia packages?","text":"","category":"section"},{"location":"faq/pkg-usage/#","page":"Using Memento in Julia packages?","title":"Using Memento in Julia packages?","text":"Some care needs to be taken when working with Memento from precompiled modules. Specifically, it is important to note that if you want folks be able to configure your logger from outside the module you'll want to register the logger in your __init__() method.","category":"page"},{"location":"faq/pkg-usage/#","page":"Using Memento in Julia packages?","title":"Using Memento in Julia packages?","text":"module MyModule\n\nusing Memento  # requires a minimum of Memento 0.5\n\n# Create our module level logger (this will get precompiled)\nconst LOGGER = getlogger(@__MODULE__)\n\n# Register the module level logger at runtime so that folks can access the logger via `get_logger(MyModule)`\n# NOTE: If this line is not included then the precompiled `MyModule.LOGGER` won't be registered at runtime.\nfunction __init__()\n    Memento.register(LOGGER)\nend\n\nend","category":"page"},{"location":"faq/testing/#testing-1","page":"How do I test my logging behaviour?","title":"How do I test my logging behaviour?","text":"","category":"section"},{"location":"faq/testing/#","page":"How do I test my logging behaviour?","title":"How do I test my logging behaviour?","text":"Memento extends various base test macros for checking whether a log message was emitted or not.","category":"page"},{"location":"faq/testing/#","page":"How do I test my logging behaviour?","title":"How do I test my logging behaviour?","text":"using Memento\nusing Memento.TestUtils\n\n# @test_log\nlogger = getlogger(\"test_log\")\nmsg = \"Hello!\"\nsetlevel!(logger, \"info\")\n@test_log(logger, \"info\", msg, Memento.info(logger, msg))\n\n# Partial matches\nmsg = \"Hello World!\"\n@test_log(logger, \"info\", \"Hello\", Memento.info(logger, msg))\n@test_log(logger, \"info\", r\"Hello*\", Memento.info(logger, msg))\n@test_log(logger, \"info\", (\"Hello\", \"World\"), Memento.info(logger, msg))\n@test_log(logger, \"info\", x -> x == msg, Memento.info(logger, msg))\n\n# @test_nolog\nlogger = getlogger(\"test_nolog\")\nsetlevel!(logger, \"info\")\n\nmsg = \"Hello!\"\ndifferent_msg = \"Goodbye\"\n\n@test_nolog(logger, \"info\", msg, nothing)\n@test_nolog(logger, \"info\", msg, Memento.debug(logger, msg))\n@test_nolog(logger, \"info\", msg, Memento.info(logger, different_msg))\n@test_nolog(logger, \"info\", msg, Memento.warn(logger, different_msg))\n@test_nolog(logger, \"info\", r\".*foo.*\", Memento.info(logger, \"baz\"))\n\n# @test_warn\nlogger = getlogger(\"test_warn\")\nmsg = \"Hello!\"\n@test_warn(logger, msg, Memento.warn(logger, \"Hello!\"))\n\n# @test_throws\nlogger = getlogger(\"test_log\")\n@test_throws(logger, ErrorException, error(logger, \"Error!\"))","category":"page"},{"location":"api/#Public-1","page":"API","title":"Public","text":"","category":"section"},{"location":"api/#Configuration-1","page":"API","title":"Configuration","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Memento.config!\nMemento.register\nMemento.reset!","category":"page"},{"location":"api/#Memento.config!","page":"API","title":"Memento.config!","text":"config!([logger], level; fmt::AbstractString, levels::Dict{AbstractString, Int}, colorized::Bool) -> Logger\n\nSets the Memento._log_levels, creates a default root logger with a DefaultHandler that prints to stdout.\n\nArguments\n\n'logger::Union{Logger, AbstractString}`: The logger to configure (optional)\nlevel::AbstractString: the minimum logging level to log message to the root logger (required).\n\nKeywords\n\nfmt::AbstractString: a format string to pass to the DefaultFormatter which describes   how to log messages (defaults to Memento.DEFAULT_FMT_STRING).   By default, format tokens should match the DefaultRecord fieldnames.\nlevels: the default logging levels to use (defaults to Memento._log_levels).\ncolorized: whether or not the message to stdout should be colorized.\nrecursive: whether or not to recursive set the level of all child loggers.\nsubstitute: whether or not to substitute the global logger with Memento (only supported on julia 0.7).\npropagate: whether the logger should also send messages to parent loggers (default: true)\n\nReturns\n\nLogger: the logger passed in, or the root logger.\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.register","page":"API","title":"Memento.register","text":"register(::Logger)\n\nRegister an existing logger with Memento if it has not already been registered.\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.reset!","page":"API","title":"Memento.reset!","text":"reset!()\n\nRemoves all registered loggers and reinitializes the root logger without any handlers.\n\n\n\n\n\n","category":"function"},{"location":"api/#Loggers-1","page":"API","title":"Loggers","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Logger\ngetlogger\nlog(::Logger, ::Record)\nlog(::Logger, ::AbstractString, ::AbstractString)\nlog(::Function, ::Logger, ::AbstractString)\ngetlevel(::Logger)\nMemento.getlevels(::Logger)\nsetlevel!(::Logger, ::AbstractString)\nsetlevel!(::Function, ::Logger, ::AbstractString)\ngethandlers\nBase.push!(::Logger, ::Handler)\ngetfilters(::Logger)\npush!(::Logger, ::Memento.Filter)\nMemento.getpath\nMemento.getchildren\nisroot\nisset\nispropagating\nsetpropagating!\nsetrecord!\ntrace\ndebug\ninfo\nnotice\nwarn\nerror\ncritical\nalert\nemergency","category":"page"},{"location":"api/#Memento.Logger","page":"API","title":"Memento.Logger","text":"Logger\n\nA Logger is responsible for converting msg strings into Records which are then passed to each handler. By default loggers propagate their message to their parent loggers.\n\nFields\n\nname::AbstractString: is the name of the logger (required).\nhandlers::Dict{Any, Handler}: is a collection of Handlers (defaults to empty Dict).\nlevel::AbstractString: the current minimum logging level for the logger to  log message to handlers (defaults to \"not_set\").\nlevels::Dict{AbstractString, Int}: a mapping of available logging levels to their   relative priority (represented as integer values) (defaults to using Memento._log_levels)\nrecord::Type: the Record type that should be produced by this logger   (defaults to DefaultRecord).\npropagate::Bool: whether or not this logger should propagate its message to its parent   (defaults to true).\n\n\n\n\n\n","category":"type"},{"location":"api/#Memento.getlogger","page":"API","title":"Memento.getlogger","text":"getlogger(name::Module) -> Logger\n\nConverts the Module to a String and calls get_logger(name::String).\n\nArguments\n\nname::Module: the Module a logger should be associated\n\nReturns\n\nLogger: the logger associated with the provided Module.\n\nReturns the logger.\n\n\n\n\n\ngetlogger(name=\"root\") -> Logger\n\nIf the logger or its parents do not exist then they are initialized with no handlers and not set.\n\nArguments\n\nname: the name of the logger (defaults to \"root\")\n\nReturns\n\nLogger: the logger.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.log-Tuple{Logger,Record}","page":"API","title":"Base.log","text":"log(logger::Logger, rec::Record)\n\nLogs rec to all its logger handlers. If this logger is not the root logger and logger.propagate is true then the parent logger is called.\n\nNOTE: This method calls all handlers asynchronously and is recursive, so you should call it with a @sync in order to synchronize all handler tasks.\n\nArguments\n\nlogger::Logger: the logger to log args to.\nrec::Record: a Record to log\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.log-Tuple{Logger,AbstractString,AbstractString}","page":"API","title":"Base.log","text":"log(logger::Logger, level::AbstractString, msg::AbstractString)\n\nCreates a Record with the logger name, level, levelnum and message and calls the other log method (which may recursively call itself on parent loggers with the created Record).\n\nArguments\n\nlogger::Logger: the logger to log to.\nlevel::AbstractString: the log level as a String\nmsg::AbstractString: the msg to log as a String\n\nThrows\n\nCompositeException: may be thrown if an error occurs in one of the handlers  (which are run with @async)\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.log-Tuple{Function,Logger,AbstractString}","page":"API","title":"Base.log","text":"log(::Function, ::Logger, ::AbstractString)\n\nSame as log(logger, level, msg), but in this case the message can be a function that returns the log message string.\n\nArguments\n\nmsg::Function: a function that returns a message String\nlogger::Logger: the logger to log to\nlevel::AbstractString: the log level as a String\n\nThrows\n\nCompositeException: may be thrown if an error occurs in one of the handlers  (which are run with @async)\n\n\n\n\n\n","category":"method"},{"location":"api/#Memento.getlevel-Tuple{Logger}","page":"API","title":"Memento.getlevel","text":"getlevel(::Logger) -> AbstractString\n\nReturns the current logger level.\n\n\n\n\n\n","category":"method"},{"location":"api/#Memento.getlevels-Tuple{Logger}","page":"API","title":"Memento.getlevels","text":"getlevels(::Logger) -> Dict\n\nGet the available log levels for a logger and their associated priorities.\n\n\n\n\n\n","category":"method"},{"location":"api/#Memento.setlevel!-Tuple{Logger,AbstractString}","page":"API","title":"Memento.setlevel!","text":"setlevel!(logger::Logger, level::AbstractString; recursive=false)\n\nChanges what level this logger should log at.\n\n\n\n\n\n","category":"method"},{"location":"api/#Memento.setlevel!-Tuple{Function,Logger,AbstractString}","page":"API","title":"Memento.setlevel!","text":"setlevel!(f::Function, logger::Logger, level::AbstractString; recursive=false)\n\nTemporarily change the level a logger will log at for the duration of the function f.\n\n\n\n\n\n","category":"method"},{"location":"api/#Memento.gethandlers","page":"API","title":"Memento.gethandlers","text":"gethandlers(logger::Logger)\n\nReturns logger.handlers\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.push!-Tuple{Logger,Handler}","page":"API","title":"Base.push!","text":"push!(logger::Logger, handler::Handler)\n\nAdds a new Handler to the logger.\n\n\n\n\n\n","category":"method"},{"location":"api/#Memento.getfilters-Tuple{Logger}","page":"API","title":"Memento.getfilters","text":"getfilters(logger::Logger) -> Array{Filter}\n\nReturns the filters for the logger.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.push!-Tuple{Logger,Memento.Filter}","page":"API","title":"Base.push!","text":"push!(logger::Logger, filter::Memento.Filter)\n\nAdds an new Filter to the logger.\n\n\n\n\n\n","category":"method"},{"location":"api/#Memento.getpath","page":"API","title":"Memento.getpath","text":"getpath(logger::Logger) -> Vector{Logger}\n\nReturns the path of logger from the root logger.\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.getchildren","page":"API","title":"Memento.getchildren","text":"getchildren(name)\n\nTakes a string representing the name of a logger and returns its children. Child loggers are extracted assuming a naming convention of \"foo.bar.baz\", where \"foo.bar.baz\" is the child of \"foo.bar\" which is the child of \"foo\".\n\nArguments\n\nname: the name of the logger.\n\nReturns\n\nVector{Logger}\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.isroot","page":"API","title":"Memento.isroot","text":"isroot(::Logger)\n\nReturns true if logger.nameis \"root\" or \"\"\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.isset","page":"API","title":"Memento.isset","text":"isset(::Logger)\n\nReturns true or false as to whether the logger is set. (ie: logger.level != \"not_set\")\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.ispropagating","page":"API","title":"Memento.ispropagating","text":"ispropagating(::Logger)\n\nReturns true or false as to whether the logger is propagating.\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.setpropagating!","page":"API","title":"Memento.setpropagating!","text":"setpropagating!([::Function], ::Logger, [::Bool])\n\nSets the logger to be propagating or not (Defaults to true).\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.setrecord!","page":"API","title":"Memento.setrecord!","text":"setrecord!(logger::Logger, rec::Type{R}) where {R<:Record}\n\nSets the record type for the logger.\n\nArguments\n\nlogger::Logger: the logger to set.\nrec::Record: A Record type to use for logging messages (ie: DefaultRecord).\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.trace","page":"API","title":"Memento.trace","text":"trace(logger::Logger, msg::AbstractString)\n\nLogs the message at the trace level.\n\ntrace(msg::Function, logger::Logger)\n\nLogs the message produced by the provided function at the trace level.\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.debug","page":"API","title":"Memento.debug","text":"debug(logger::Logger, msg::AbstractString)\n\nLogs the message at the debug level.\n\ndebug(msg::Function, logger::Logger)\n\nLogs the message produced by the provided function at the debug level.\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.info","page":"API","title":"Memento.info","text":"info(logger::Logger, msg::AbstractString)\n\nLogs the message at the info level.\n\ninfo(msg::Function, logger::Logger)\n\nLogs the message produced by the provided function at the info level.\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.notice","page":"API","title":"Memento.notice","text":"notice(logger::Logger, msg::AbstractString)\n\nLogs the message at the notice level.\n\nnotice(msg::Function, logger::Logger)\n\nLogs the message produced by the provided function at the notice level.\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.warn","page":"API","title":"Memento.warn","text":"warn(logger::Logger, msg::AbstractString)\n\nLogs the message at the warn level.\n\nwarn(msg::Function, logger::Logger)\n\nLogs the message produced by the provided function at the warn level.\n\n\n\n\n\n","category":"function"},{"location":"api/#Base.error","page":"API","title":"Base.error","text":"error(logger::Logger, msg::AbstractString)\n\nLogs the message at the error level and throws an ErrorException with that message\n\nerror(msg::Function, logger::Logger)\n\nLogs the message produced by the provided function at the error level and throws an ErrorException with that message.\n\nerror(logger::Logger, exc::Exception)\n\nCalls error(logger, msg) with the contents of the Exception, then throw the Exception. If the exception is a CompositeException, each contained exception is logged, then the CompositeException is thrown.\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.critical","page":"API","title":"Memento.critical","text":"critical(logger::Logger, msg::AbstractString)\n\nLogs the message at the critical level and throws an ErrorException with that message\n\ncritical(msg::Function, logger::Logger)\n\nLogs the message produced by the provided function at the critical level and throws an ErrorException with that message.\n\ncritical(logger::Logger, exc::Exception)\n\nCalls critical(logger, msg) with the contents of the Exception, then throw the Exception. If the exception is a CompositeException, each contained exception is logged, then the CompositeException is thrown.\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.alert","page":"API","title":"Memento.alert","text":"alert(logger::Logger, msg::AbstractString)\n\nLogs the message at the alert level and throws an ErrorException with that message\n\nalert(msg::Function, logger::Logger)\n\nLogs the message produced by the provided function at the alert level and throws an ErrorException with that message.\n\nalert(logger::Logger, exc::Exception)\n\nCalls alert(logger, msg) with the contents of the Exception, then throw the Exception. If the exception is a CompositeException, each contained exception is logged, then the CompositeException is thrown.\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.emergency","page":"API","title":"Memento.emergency","text":"emergency(logger::Logger, msg::AbstractString)\n\nLogs the message at the emergency level and throws an ErrorException with that message\n\nemergency(msg::Function, logger::Logger)\n\nLogs the message produced by the provided function at the emergency level and throws an ErrorException with that message.\n\nemergency(logger::Logger, exc::Exception)\n\nCalls emergency(logger, msg) with the contents of the Exception, then throw the Exception. If the exception is a CompositeException, each contained exception is logged, then the CompositeException is thrown.\n\n\n\n\n\n","category":"function"},{"location":"api/#Handlers-1","page":"API","title":"Handlers","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Handler\nDefaultHandler\nEscalator\nlog(::Handler, ::Record)\ngetlevel(::Handler)\ngetfilters(::Handler)\nMemento.emit\nsetlevel!(::DefaultHandler, ::AbstractString)\npush!(::DefaultHandler, ::Memento.Filter)\nMemento.getlevels(::Handler)\nMemento.setup_opts","category":"page"},{"location":"api/#Memento.Handler","page":"API","title":"Memento.Handler","text":"Handler\n\nManage formatting Records and logging the resulting String. All Handler subtypes must implement at least 1 log(::Handler, ::Record) method.\n\nNOTE: Handlers can be useful if you need to special case logging behaviour based on the Formatter, IO and/or Record types.\n\n\n\n\n\n","category":"type"},{"location":"api/#Memento.DefaultHandler","page":"API","title":"Memento.DefaultHandler","text":"DefaultHanlder\n\nThe DefaultHandler manages any Formatter, IO and Record.\n\nFields:\n\nfmt: a Formatter for converting Records to Strings\nio: an IO type for printing String to.\nopts: a dictionary of optional arguments such as :iscolorized and :colors   Ex) ```Dict{Symbol, Any}(           :iscolorized => true,           :opts[:colors] => Dict{AbstractString, Symbol}(               \"debug\" => :blue,               \"info\" => :green,               ...           )       )```\n\n\n\n\n\n","category":"type"},{"location":"api/#Memento.Escalator","page":"API","title":"Memento.Escalator","text":"Escalator(fmt=DefaultFormatter(); level=\"warn\", levels=nothing)\n\nEscalates any logs it sees above a certain level and throws an EscalationError.\n\nArguments\n\nfmt::Formatter: for converting Records to error messages Strings\n\nKeyword Arguments\n\nlevel: threshold level for when to error, otherwise this is a no-op\nlevels: an alternate levels dictionary if we're considering non-default levels\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.log-Tuple{Handler,Record}","page":"API","title":"Base.log","text":"log(handler::Handler, rec::Record)\n\nChecks the Handler filters and if they all pass then emit the record.\n\n\n\n\n\n","category":"method"},{"location":"api/#Memento.getlevel-Tuple{Handler}","page":"API","title":"Memento.getlevel","text":"getlevel(::Handler) -> AbstractString\n\nReturns the current handler level. The default is \"not_set\".\n\n\n\n\n\n","category":"method"},{"location":"api/#Memento.getfilters-Tuple{Handler}","page":"API","title":"Memento.getfilters","text":"getfilters(handler::Handler) -> Array{Memento.Filter}\n\nReturns the filters for the handler. The default is the standard level-based filter.\n\n\n\n\n\n","category":"method"},{"location":"api/#Memento.emit","page":"API","title":"Memento.emit","text":"emit{F, O}(handler::DefaultHandler{F ,O}, rec::Record) where {F<:Formatter, O<:IO}\n\nHandles printing any Record with any Formatter and IO types.\n\n\n\n\n\nemit(\n    handler::DefaultHandler{F, O},\n    rec::Record\n) where {F<:Formatter, O<:Syslogs.Syslog}\n\nHandles printing any records with any Formatter and a Syslog IO type.\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.setlevel!-Tuple{DefaultHandler,AbstractString}","page":"API","title":"Memento.setlevel!","text":"setlevel!(handler::DefaultHandler, level::AbstractString)\n\nSets the minimum level required to emit the record from the handler.\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.push!-Tuple{DefaultHandler,Memento.Filter}","page":"API","title":"Base.push!","text":"push!(handler::DefaultHandler, filter::Memento.Filter)\n\nAdds an new Filter to the handler.\n\n\n\n\n\n","category":"method"},{"location":"api/#Memento.getlevels-Tuple{Handler}","page":"API","title":"Memento.getlevels","text":"getlevels(::Handler) -> Union{Dict, Nothing}\n\nGet the available log levels for a handler and their associated priorities. The default is nothing, for handlers which do not perform level-based filtering.\n\n\n\n\n\n","category":"method"},{"location":"api/#Memento.setup_opts","page":"API","title":"Memento.setup_opts","text":"setup_opts(opts) -> Dict\n\nSets the default :colors if opts[:is_colorized] == true.\n\n\n\n\n\n","category":"function"},{"location":"api/#Formatters-1","page":"API","title":"Formatters","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Formatter\nDefaultFormatter\nDictFormatter\nformat","category":"page"},{"location":"api/#Memento.Formatter","page":"API","title":"Memento.Formatter","text":"Formatter\n\nA Formatter must implement a format(::Formatter, ::Record) method which takes a Record and returns a String representation of the log Record.\n\n\n\n\n\n","category":"type"},{"location":"api/#Memento.DefaultFormatter","page":"API","title":"Memento.DefaultFormatter","text":"DefaultFormatter\n\nThe DefaultFormatter uses a simple format string to build the log message. Fields from the Record to be used should be wrapped curly brackets.\n\nEx) \"[{level} | {name}]: {msg}\" will print message of the form [info | root]: my info message. [warn | root]: my warning message. ...\n\n\n\n\n\n","category":"type"},{"location":"api/#Memento.DictFormatter","page":"API","title":"Memento.DictFormatter","text":"DictFormatter([aliases, serializer])\n\nFormats the record to Dict that is amenable to serialization formats such as JSON and then runs the serializer function on the produced dictionary.\n\nArguments\n\naliases::Dict{Symbol, Symbol}: Mapping where the keys represent aliases and values\n\nrepresent existing record attributes to include in the dictionary (defaults to all attributes).\n\nserializer::Function: A function that takes a Dictionary and returns a string. Defaults\n\nto string(dict).\n\n\n\n\n\n","category":"type"},{"location":"api/#Memento.format","page":"API","title":"Memento.format","text":"format(::DefaultFormatter, ::Record) -> String\n\nIteratively replaces entries in the format string with the appropriate fields in the Record.\n\n\n\n\n\nformat(::DictFormatter, ::Record) -> Dict\n\nConverts :date, :lookup and :stacktrace to strings and dicts respectively.\n\n\n\n\n\n","category":"function"},{"location":"api/#Records-1","page":"API","title":"Records","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Record\nMemento.getlevel(::Record)\nDefaultRecord\nMemento.Attribute\nMemento.AttributeRecord\nBase.get(::Memento.Attribute)\nBase.Dict(::Record)\nMemento.get_trace\nMemento.get_lookup","category":"page"},{"location":"api/#Memento.Record","page":"API","title":"Memento.Record","text":"Record\n\nA dictionary-like container with Symbol keys used to store information about a log events including the msg, date, level, stacktrace, etc. Formatters use Records to format log message strings.\n\nYou can access the properties of a Record by using getproperty (ie: record.msg).\n\nSubtypes of Record should implement getproperty(::MyRecord, ::Symbol) and key-value pair iteration.\n\n\n\n\n\n","category":"type"},{"location":"api/#Memento.getlevel-Tuple{Record}","page":"API","title":"Memento.getlevel","text":"getlevel(::Record) -> AbstractString\n\nReturns the record level.\n\n\n\n\n\n","category":"method"},{"location":"api/#Memento.DefaultRecord","page":"API","title":"Memento.DefaultRecord","text":"DefaultRecord <: AttributeRecord\n\nStores the most common logging event information. NOTE: if you'd like more logging attributes you can:\n\nadd them to DefaultRecord and open a pull request if the new attributes are applicable to most applications.\nmake a custom Record type.\n\nFields\n\ndate::Attribute{ZonedDateTime}: timestamp of log event\nlevel::Attribute{AbstractString}: log level\nlevelnum::Attribute{Int}: integer value for log level\nmsg::Attribute{AbstractString}: the log message itself\nname::Attribute{AbstractString}: the name of the source logger\npid::Attribute{Int}: the pid of where the log event occured\nlookup::Attribute{StackFrame}: the top StackFrame\nstacktrace::Attribute{StackTrace}: a stacktrace\n\n\n\n\n\n","category":"type"},{"location":"api/#Memento.Attribute","page":"API","title":"Memento.Attribute","text":"Attribute\n\nAn Attribute represents a lazily evaluated field in a log Record.\n\nFields\n\nf::Function: A function to evaluate in order to get a value if one is not set.\nx::Union{Some{T}, Nothing}: A value that may or may not exist yet.\n\n\n\n\n\n","category":"type"},{"location":"api/#Memento.AttributeRecord","page":"API","title":"Memento.AttributeRecord","text":"AttributeRecord <: Record\n\nA Record which stores its properties as Attributes for lazy evaluation.\n\nCalling getproperty or iterating will evaluate and cache the properties accessed.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.get-Tuple{Memento.Attribute}","page":"API","title":"Base.get","text":"get(attr::Attribute{T}) -> T\n\nRun set attr.x to the output of attr.f if attr.x is not already set. We then return the value stored in attr.x\n\n\n\n\n\n","category":"method"},{"location":"api/#Base.Dict-Tuple{Record}","page":"API","title":"Base.Dict","text":"Dict(rec::Record)\n\nExtracts the Record and its properties into a Dict\n\nwarn: Warn\nOn AttributeRecords this may be an expensive operation, so you probably don't want to do this for every log record unless you're planning on using every Attribute.\n\n\n\n\n\n","category":"method"},{"location":"api/#Memento.get_trace","page":"API","title":"Memento.get_trace","text":"get_trace()\n\nReturns the StackTrace with StackFrames from the Memento module filtered out.\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.get_lookup","page":"API","title":"Memento.get_lookup","text":"get_lookup(trace::Attribute{StackTrace})\n\nReturns the top StackFrame for trace if it isn't empty.\n\n\n\n\n\n","category":"function"},{"location":"api/#IO-1","page":"API","title":"IO","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"FileRoller\nMemento.getfile\nMemento.getsuffix","category":"page"},{"location":"api/#Memento.FileRoller","page":"API","title":"Memento.FileRoller","text":"FileRoller <: IO\n\nIs responsible for managing a rolling log file.\n\nFields\n\nprefix::AbstractString: filename prefix for the log.\nfolder::AbstractString: directory where the log should be written.\nfilepath::AbstractString: the full filepath for the log\nfile::IO: the current file IO handle\nbyteswritten::Int64: keeps track of how many bytes have been written to the current file.\nmax_sz::Int: the maximum number of bytes written to a file before rolling over to another.\n\n\n\n\n\n","category":"type"},{"location":"api/#Memento.getfile","page":"API","title":"Memento.getfile","text":"getfile(folder::AbstractString, prefix::AbstractString) -> String, IO\n\nGrabs the next log file.\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.getsuffix","page":"API","title":"Memento.getsuffix","text":"getsuffix(::Integer) -> String\n\nFormats the nth file suffix.\n\n\n\n\n\n","category":"function"},{"location":"api/#Memento.TestUtils-1","page":"API","title":"Memento.TestUtils","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Memento.TestUtils.@test_log\nMemento.TestUtils.@test_nolog\nMemento.TestUtils.@test_warn\nMemento.TestUtils.@test_throws","category":"page"},{"location":"api/#Memento.TestUtils.@test_log","page":"API","title":"Memento.TestUtils.@test_log","text":"@test_log(logger, level, msg, expr)\n\nTest that the expression expr emits a record in the logger with the specified level string and contains the msg string or matches the msg regular expression. If msg is a boolean function, tests whether msg(output) returns true. If msg is a tuple or array, checks that the output contains/matches each item in msg. Returns the result of evaluating expr.\n\nThis will temporarily add a test handler to the logger which will always be removed after executing the expression.\n\nSee also @test_nolog to check for the absence of a record.\n\nExample\n\njulia> using Memento, Memento.TestUtils\n\njulia> logger = getlogger(\"test_log\");\n\njulia> m = \"Hello World!\";\n\njulia> @test_log logger \"info\" \"Hello\" info(logger, m)\n\njulia> @test_log logger \"info\" r\"^Hello\" info(logger, m)\n\njulia> @test_log logger \"info\" (\"Hello\", r\"World!$\") info(logger, m)  # All elements occursin\n\n\n\n\n\n","category":"macro"},{"location":"api/#Memento.TestUtils.@test_nolog","page":"API","title":"Memento.TestUtils.@test_nolog","text":"@test_nolog(logger, level, msg, expr)\n\nTest that the expression expr does not emit a record in the logger with the specified level string containing the msg string or matching the msg regular expression.\n\nSee also @test_log for further details.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Test.@test_warn","page":"API","title":"Test.@test_warn","text":"@test_warn(logger, msg, expr)\n\nConvenience macro that calls @test_log(logger, \"warn\", msg, expr).\n\n\n\n\n\n","category":"macro"},{"location":"api/#Test.@test_throws","page":"API","title":"Test.@test_throws","text":"@test_throws(logger, extype, expr)\n\nDisables the logger and calls @test_throws extype expr.\n\n\n\n\n\n","category":"macro"},{"location":"api/#Misc-1","page":"API","title":"Misc","text":"","category":"section"},{"location":"api/#","page":"API","title":"API","text":"Memento.Filter\nMemento.EscalationError\nMemento.LoggerSerializationError","category":"page"},{"location":"api/#Memento.Filter","page":"API","title":"Memento.Filter","text":"Filter\n\nA wrapper around a function that takes a log Record and returns a bool whether to skip logging it.\n\nFields\n\nf::Function: a function that should return a bool given a Record\n\n\n\n\n\n","category":"type"},{"location":"api/#Memento.EscalationError","page":"API","title":"Memento.EscalationError","text":"EscalationError(msg)\n\nAn error type for log records that have been escalated to errors.\n\n\n\n\n\n","category":"type"},{"location":"api/#Memento.LoggerSerializationError","page":"API","title":"Memento.LoggerSerializationError","text":"LoggerSerializationError(logger::Logger)\n\nProvides a helpful error message when a logger cannot be serialized.\n\n\n\n\n\n","category":"type"},{"location":"contributing/#Get-started-contributing-1","page":"Contributing","title":"Get started contributing","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Detailed docs on contributing to Julia packages can be found here.","category":"page"},{"location":"contributing/#Code-and-docs-1","page":"Contributing","title":"Code and docs","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"To start hacking code or writing docs, simply:","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"julia> using Pkg; Pkg.develop(\"Memento\")\nMake your changes.\nTest your changes with julia --compiled-modules=no -e 'using Pkg; Pkg.test(\"Memento\"; coverage=true)'\nCheck that your changes haven't reduced the test coverage. From the root Memento package folder run julia -e 'using Coverage; Coverage.get_summary(process_folder())'.\nMake a pull request to Memento and share your changes with the rest of the community.","category":"page"},{"location":"contributing/#Bugs,-features,-and-requests-1","page":"Contributing","title":"Bugs, features, and requests","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Feel free to file issues when you encounter bugs, think of interesting features you'd like to see, or when there are important changes not yet included in a release and you'd like us to tag a new version.","category":"page"},{"location":"contributing/#Submitting-your-contributions-1","page":"Contributing","title":"Submitting your contributions","text":"","category":"section"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"By contributing code to Memento, you are agreeing to release your work under the MIT License.","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"We love contributions in the form of pull requests! Assuming you've been working in a repo checked out as above, this should be easy to do. For a detailed walkthrough, check here, otherwise:","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Navigate to Memento.jl and create a fork.\ngit remote add origin https://github.com/user/Memento.jl.git\ngit push origin master\nSubmit your changes as a pull request!","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"For pull requests to be accepted we require that the changes:","category":"page"},{"location":"contributing/#","page":"Contributing","title":"Contributing","text":"Pass on travis and appveyor\nMaintain 100% test coverage","category":"page"}]
}
